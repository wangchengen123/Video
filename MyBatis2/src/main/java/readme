Many 2 One(多对一)
在增加的时候,由于关系是由多的一方来维护,所以我们在每个员工对象中让其有一个部门对象,插入的时候
需要先插入部门等到数据库返回部门ID之后在执行增加员工的操作,这样在增加员工的时候才能知道部门ID是多少
  1.在多的一方model实体类中添加一个一的一方对象(emp类中添加一个private Dept dept)
  2.在mapper.xml resultMap 中使用association来映射这个单个对象
  3.编写查询的SQL 指定其结果集为对应的resultMap
  	1.可以使用单表查询,将查询出来的结果集中的一列作为参数用于调用association 对应的SQL语句
  	2.直接使用多表查询,将查询出来的结果集通过resultMap封装,使用这种方式association不需要指定sql
One 2 Many(一对多)
  1.在一的一方model实体类中添加一个多的一方集合对象(dept 类中添加一个private List<Emp> emps)
  2.在mapper.xml resultMap中使用collection来映射这个集合,对应java类型为ofType
  3.编写查询的SQL 指定其结果集为对应的resultMap
  	1.可以使用单表查询,将查询出来的结果集中的一列作为参数用于调用association 对应的SQL语句
  	2.直接使用多表查询,将查询出来的结果集通过resultMap封装,使用这种方式association不需要指定sql
  
需要映射的对象是一个的时候使用association,如果需要映射的是集合的情况下使用collecation

延迟加载:当查询的时候,只有在调用相关联对象的时候才会去发送SQL查询相关联对象,可以减少查询数据库的次数,
需要在mybatis配置文件中开启.

N+1问题: 当相关联对象较多的时候,查询数据会产生相关联对象数量+1(本身查询SQL)的SQL语句.
 解决:
 
缓存: 可以认为是内存中的一块区域,用来暂存一些数据,当相关应用被关闭后缓存会被清空.
MyBatis的一级缓存是sqlSession级别,在多个数据库会话中间不共享,如果会话关闭则缓存被清空.
 
MyBatis二级缓存(SqlSessionFactory级别):
 	默认是关闭的,需要在mapper.xml开启,只有当sqlsession关闭的时候,查询出来的数据才会被放到缓存中.
 	
MyBatis默认只支持一个参数的传递:
	1.如果需要传入多个参数,可以在xml中根据下标取值  #{0},#{1}. 	
 	2.我们可以把参数类型变成一个Map,然后在xml中通过map的key进行取值
 	3.使用Param注解让mybatis自动给我们的参数生成key
 	
 	
#与$
	#代表的是预编译对象,参数通过preparedStatement占位符的形式传递过去
	$参数是直接通过字符串拼接的方式拼接到sql中,无法防止SQL注入.使用$拼接参数的时候需要配合Param注解一起使用
什么时候用# 什么时候用$
	一般情况下所有的查询几乎都使用#来传递参数,因为其代表预编译对象可以防止sql注入,执行效率高
	但是如果我们传递的参数是数据库名的话,如果使用#来传递参数会在参数的前后加上'' 这样会导致
	查询出来的数据不符合我们的要求,
 	